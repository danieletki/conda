"""Frida helpers for BLE pentest attacks.

This module is intentionally lightweight and is only imported by attacks that
opt-in to Frida instrumentation.

Platform tooling prerequisites
------------------------------
- Install the Python bindings (``pip install frida``) and the CLI tools
  (``pip install frida-tools``).
- Ensure a matching ``frida-server`` is running on the target device.

  Android
    - Enable USB debugging
    - Push/start ``frida-server`` (rooted device/emulator typically required)
    - Optionally forward the default port: ``adb forward tcp:27042 tcp:27042``

  iOS
    - Run on a jailbroken device or use a debugserver-based workflow
    - Start ``frida-server`` and connect via USB/remote endpoint.

These helpers support connecting to a remote Frida server (``host:port``) or a
USB-attached device.
"""

from __future__ import annotations

import asyncio
from dataclasses import dataclass
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable
    from typing import Any


@dataclass(frozen=True)
class FridaConnectionConfig:
    endpoint: str | None = None
    timeout_seconds: float = 5.0


def script_path(script_name: str) -> Path:
    base_dir = Path(__file__).resolve().parent
    scripts_dir = base_dir / "frida_scripts"
    return scripts_dir / script_name


def load_script(script_name: str) -> str:
    path = script_path(script_name)
    return path.read_text(encoding="utf-8")


def _import_frida():
    try:
        import frida  # type: ignore[import-not-found]

        return frida
    except ModuleNotFoundError as exc:  # pragma: no cover
        raise RuntimeError(
            "Frida instrumentation requires the 'frida' Python package. "
            "Install tools/ble_pentest/requirements-ble.txt"
        ) from exc


def get_device(config: FridaConnectionConfig):
    frida = _import_frida()

    endpoint = (config.endpoint or "").strip().lower() or "usb"
    if endpoint in {"usb", "usb:"}:
        return frida.get_usb_device(timeout=int(config.timeout_seconds))
    if endpoint in {"local", "local:"}:
        return frida.get_local_device()

    manager = frida.get_device_manager()
    return manager.add_remote_device(config.endpoint)


def parse_message(message: dict[str, Any]) -> tuple[dict[str, Any] | None, str | None]:
    """Parse a Frida message callback payload.

    Returns
    -------
    (event, error)
        Exactly one of these is non-null.
    """

    msg_type = message.get("type")
    if msg_type == "send":
        payload = message.get("payload")
        if isinstance(payload, dict):
            return payload, None
        return {"type": "frida.payload", "value": payload}, None

    if msg_type == "error":
        desc = message.get("description") or "frida script error"
        stack = message.get("stack")
        if stack:
            return None, f"{desc}\n{stack}"
        return None, str(desc)

    return None, f"Unhandled Frida message type: {msg_type!r}"


async def collect_events(
    *,
    connection: FridaConnectionConfig,
    target: str,
    script_source: str,
    duration_seconds: float = 0.0,
    on_event: Callable[[dict[str, Any]], None] | None = None,
) -> tuple[list[dict[str, Any]], list[str]]:
    """Attach to ``target`` and collect Frida ``send()`` events."""

    device = get_device(connection)
    session = device.attach(target)
    script = session.create_script(script_source)

    events: list[dict[str, Any]] = []
    errors: list[str] = []

    def handle(message: dict[str, Any], data: Any) -> None:  # noqa: ARG001
        event, error = parse_message(message)
        if event is not None:
            events.append(event)
            if on_event is not None:
                on_event(event)
            return
        if error is not None:
            errors.append(error)

    script.on("message", handle)
    script.load()

    try:
        if duration_seconds > 0:
            await asyncio.sleep(duration_seconds)
    finally:
        if hasattr(script, "unload"):
            try:
                script.unload()
            except Exception:  # noqa: BLE001
                pass
        if hasattr(session, "detach"):
            try:
                session.detach()
            except Exception:  # noqa: BLE001
                pass

    return events, errors
