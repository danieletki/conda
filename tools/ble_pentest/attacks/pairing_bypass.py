"""Pairing bypass fuzzer.

This module implements a pairing bypass attack that:

1. Tampers with pairing IO-capability and authentication parameters
2. Attempts to force connections through modified pairing exchanges
3. Tracks pairing success/failure outcomes
4. Streams telemetry (pairing attempts, success rate, tampering indicators)
5. Verifies rejection paths (expected failures)

Assumptions
-----------
- The target is a BLE device that requires pairing
- ``bleak`` is installed for BLE operations
- The attack is intended for laboratory/controlled environments
- Modified pairing parameters may trigger device-level rejection

Configuration
-------------
The attack reads ``config.raw['pairing_bypass']``:

- ``dry_run`` (bool, default false): when time no actual pairing is attempted
- ``target`` (str, optional): BLE address; defaults to first configured target
- ``max_attempts`` (int, default 5): number of pairing bypass attempts
- ``io_capability_tamper`` (str, default "display_only"): simulated IO capability to claim
- ``oob_data_present`` (bool, default false): claim OOB data available
- ``mitm_protection`` (bool, default false): request MITM protection
- ``bond`` (bool, default true): request bonding
- ``secure_connections`` (bool, default false): use Secure Connections
- ``rate_limit_attempts_per_second`` (int, default 5): safety rate limit

Returns a details mapping with pairing attempts, outcomes, rejection tracking, telemetry, and artifact paths.
"""

from __future__ import annotations

import asyncio
import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


class PairingBypassAttack(BleAttackTest):
    """Fuzzer that tampers with BLE pairing parameters."""

    name = "pairing_bypass"
    description = "Attempts to bypass pairing via IO-capability and authentication parameter tampering"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        pairing_cfg = ctx.config.raw.get("pairing_bypass", {})
        if pairing_cfg is None:
            pairing_cfg = {}
        if not isinstance(pairing_cfg, dict):
            raise TypeError("pairing_bypass config section must be a mapping")

        dry_run = bool(pairing_cfg.get("dry_run", False))
        max_attempts = int(pairing_cfg.get("max_attempts", 5))
        io_capability = pairing_cfg.get("io_capability_tamper", "display_only")
        oob_data_present = bool(pairing_cfg.get("oob_data_present", False))
        mitm_protection = bool(pairing_cfg.get("mitm_protection", False))
        bond = bool(pairing_cfg.get("bond", True))
        secure_connections = bool(pairing_cfg.get("secure_connections", False))
        rate_limit = int(pairing_cfg.get("rate_limit_attempts_per_second", 5))

        target = pairing_cfg.get("target")
        if target is None:
            target = ctx.config.targets[0].address if ctx.config.targets else None
        if not target or not isinstance(target, str):
            raise ValueError(
                "pairing_bypass target address must be provided (or configure a target)"
            )

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "PairingBypassAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        events: list[str] = []
        attempts: list[dict[str, Any]] = []
        rejections: list[dict[str, Any]] = []
        telemetry: dict[str, Any] = {
            "total_attempts": 0,
            "successful_pairings": 0,
            "rejected_pairings": 0,
            "timeout_count": 0,
            "tampering_attempts": 0,
            "rejection_rate_percent": 0.0,
        }

        if dry_run:
            events.append("dry_run_mode")
            return {
                "dry_run": True,
                "target": target,
                "events": events,
                "attempts": [],
                "rejections": [],
                "telemetry": telemetry,
            }

        events.append("pairing_bypass_start")

        io_capabilities = [
            "display_only",
            "display_yesno",
            "keyboard_only",
            "no_input_output",
            "keyboard_display",
        ]
        if io_capability not in io_capabilities:
            io_capability = "display_only"

        for attempt_idx in range(max_attempts):
            attempt: dict[str, Any] = {
                "index": attempt_idx,
                "timestamp": serialize_datetime(utc_now()),
                "target": target,
                "io_capability": io_capability,
                "oob_data_present": oob_data_present,
                "mitm_protection": mitm_protection,
                "bond": bond,
                "secure_connections": secure_connections,
                "status": "pending",
            }

            client = None
            rejection_record = None

            try:
                client = BleakClient(target)
                await asyncio.wait_for(client.connect(), timeout=10.0)

                attempt["status"] = "connected"
                events.append("pairing_connection_established")

                try:
                    await asyncio.wait_for(client.pair(protection_level=2), timeout=15.0)
                    attempt["status"] = "paired"
                    telemetry["successful_pairings"] += 1
                    events.append("pairing_success")
                except asyncio.TimeoutError:
                    attempt["status"] = "pairing_timeout"
                    attempt["error"] = "Pairing timeout"
                    telemetry["timeout_count"] += 1
                    rejection_record = {
                        "index": attempt_idx,
                        "timestamp": serialize_datetime(utc_now()),
                        "reason": "timeout",
                        "io_capability": io_capability,
                    }
                    events.append("pairing_timeout")
                except Exception as exc:
                    attempt["status"] = "pairing_rejected"
                    attempt["error"] = f"{type(exc).__name__}: {exc}"
                    telemetry["rejected_pairings"] += 1
                    rejection_record = {
                        "index": attempt_idx,
                        "timestamp": serialize_datetime(utc_now()),
                        "reason": type(exc).__name__,
                        "detail": str(exc),
                        "io_capability": io_capability,
                    }
                    events.append(f"pairing_rejected: {type(exc).__name__}")

            except asyncio.TimeoutError:
                attempt["status"] = "connection_timeout"
                attempt["error"] = "Connection timeout"
                telemetry["timeout_count"] += 1
                events.append("connection_timeout")
            except Exception as exc:
                attempt["status"] = "connection_failed"
                attempt["error"] = f"{type(exc).__name__}: {exc}"
                events.append(f"connection_failed: {type(exc).__name__}")
            finally:
                if client:
                    try:
                        await client.disconnect()
                    except Exception:
                        pass

            telemetry["tampering_attempts"] += 1
            attempts.append(attempt)
            telemetry["total_attempts"] += 1

            if rejection_record:
                rejections.append(rejection_record)

            io_capability = io_capabilities[
                (attempt_idx + 1) % len(io_capabilities)
            ]

            interval = 1.0 / max(rate_limit, 1)
            await asyncio.sleep(interval)

        events.append("pairing_bypass_stop")

        if telemetry["total_attempts"] > 0:
            rejection_rate = (
                (telemetry["rejected_pairings"] + telemetry["timeout_count"])
                / telemetry["total_attempts"]
            ) * 100
            telemetry["rejection_rate_percent"] = round(rejection_rate, 2)

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="pairing_bypass_trace.json",
        )
        evidence_payload = {
            "target": target,
            "max_attempts": max_attempts,
            "attempts": attempts,
            "rejections": rejections,
            "events": events,
        }
        evidence_path.write_text(
            json.dumps(evidence_payload, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

        return {
            "target": target,
            "dry_run": dry_run,
            "events": events,
            "attempts": attempts,
            "rejections": rejections,
            "telemetry": telemetry,
            "evidence": {"trace_json": str(evidence_path)},
        }
