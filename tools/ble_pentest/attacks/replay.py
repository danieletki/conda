"""Replay attack helpers.

This module implements a simple *capture then replay* workflow:

1. Connect to a target with ``bleak``.
2. Capture a number of reads from a configured characteristic.
3. Replay previously captured values via characteristic writes.
4. Apply lightweight heuristics to flag missing timestamp/nonce validation.

Assumptions
-----------
- The target exposes a characteristic where reads/writes correspond to an
  authenticated exchange.
- The harness cannot reliably infer protocol semantics; findings are heuristic
  and intended for analyst review.

Configuration
-------------
The attack reads ``config.raw['replay']``:

- ``characteristic_uuid`` (str, required): UUID to read/write.
- ``target`` (str, optional): BLE address; defaults to the first configured target.
- ``capture_count`` (int, default 2): number of reads to capture.
- ``replay_delay_seconds`` (float, default 0.0): delay between replay attempts.
- ``write_response`` (bool, default true): request write-with-response.
- ``nonce_bytes`` (int, default 4): if >0, treat the last ``nonce_bytes`` of each
  capture as a nonce and check whether it changes.

Returns a details mapping with capture/replay traces, findings, and artifact paths.
"""

from __future__ import annotations

import asyncio
import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


def _tail_nonce(payload: bytes, nonce_bytes: int) -> str | None:
    if nonce_bytes <= 0:
        return None
    if len(payload) < nonce_bytes:
        return None
    return payload[-nonce_bytes:].hex()


class ReplayAttack(BleAttackTest):
    """Capture and replay characteristic payloads."""

    name = "replay"
    description = "Captures characteristic reads and replays them to detect missing nonce/timestamp validation"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        replay_cfg = ctx.config.raw.get("replay", {})
        if replay_cfg is None:
            replay_cfg = {}
        if not isinstance(replay_cfg, dict):
            raise TypeError("replay config section must be a mapping")

        characteristic_uuid = replay_cfg.get("characteristic_uuid")
        if not characteristic_uuid or not isinstance(characteristic_uuid, str):
            raise ValueError("replay.characteristic_uuid must be provided")

        target = replay_cfg.get("target")
        if target is None:
            target = ctx.config.targets[0].address if ctx.config.targets else None
        if not target or not isinstance(target, str):
            raise ValueError(
                "replay target address must be provided (or configure a target)"
            )

        capture_count = int(replay_cfg.get("capture_count", 2))
        replay_delay_seconds = float(replay_cfg.get("replay_delay_seconds", 0.0))
        write_response = bool(replay_cfg.get("write_response", True))
        nonce_bytes = int(replay_cfg.get("nonce_bytes", 4))

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "ReplayAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        events: list[str] = []
        captures: list[dict[str, Any]] = []
        replays: list[dict[str, Any]] = []
        findings: list[dict[str, Any]] = []

        client = BleakClient(target)
        await client.connect()
        events.append("connected")
        try:
            for i in range(max(capture_count, 0)):
                payload = await client.read_gatt_char(characteristic_uuid)
                if isinstance(payload, bytearray):
                    payload = bytes(payload)
                if not isinstance(payload, (bytes, bytearray)):
                    raise TypeError("bleak read_gatt_char must return bytes")

                captures.append(
                    {
                        "index": i,
                        "timestamp": serialize_datetime(utc_now()),
                        "value_hex": bytes(payload).hex(),
                        "nonce_hex": _tail_nonce(bytes(payload), nonce_bytes),
                    }
                )

            nonces = [c["nonce_hex"] for c in captures if c.get("nonce_hex")]
            if nonces and len(set(nonces)) == 1 and len(nonces) > 1:
                findings.append(
                    {
                        "type": "nonce_static_suspected",
                        "detail": f"Nonce (last {nonce_bytes} bytes) did not change across captures",
                    }
                )

            values = [c["value_hex"] for c in captures]
            if values and len(set(values)) == 1 and len(values) > 1:
                findings.append(
                    {
                        "type": "payload_static_suspected",
                        "detail": "Captured payload did not change across reads; may indicate missing per-message nonce/timestamp",
                    }
                )

            for capture in captures:
                if replay_delay_seconds > 0:
                    await asyncio.sleep(replay_delay_seconds)

                payload = bytes.fromhex(capture["value_hex"])
                record: dict[str, Any] = {
                    "captured_index": capture["index"],
                    "timestamp": serialize_datetime(utc_now()),
                    "value_hex": capture["value_hex"],
                    "status": "pending",
                }

                try:
                    await client.write_gatt_char(
                        characteristic_uuid, payload, response=write_response
                    )
                    record["status"] = "accepted"
                except Exception as exc:  # noqa: BLE001
                    record["status"] = "rejected"
                    record["error"] = f"{type(exc).__name__}: {exc}"

                replays.append(record)

            if any(r["status"] == "accepted" for r in replays) and (
                findings or capture_count > 1
            ):
                findings.append(
                    {
                        "type": "replay_write_accepted",
                        "detail": "At least one replay write was accepted; verify device enforces nonce/timestamp validation",
                    }
                )
        finally:
            events.append("disconnect")
            await client.disconnect()

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="replay_trace.json",
        )
        evidence_payload = {
            "target": target,
            "characteristic_uuid": characteristic_uuid,
            "captures": captures,
            "replays": replays,
            "events": events,
        }
        evidence_path.write_text(
            json.dumps(evidence_payload, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

        return {
            "target": target,
            "characteristic_uuid": characteristic_uuid,
            "events": events,
            "captures": captures,
            "replays": replays,
            "findings": findings,
            "evidence": {"trace_json": str(evidence_path)},
        }
