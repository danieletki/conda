// Device Host Exposure (iOS)
//
// Inject into an iOS BLE client application with Frida.
//
// This script emits coarse-grained signals for filesystem/network/Bluetooth API
// usage. Extend hooks to match the target's architecture.

'use strict';

function emit(payload) {
  send(payload);
}

emit({ type: 'meta', script: 'device_host_exposure', platform: 'ios', ts: Date.now() });

if (!ObjC.available) {
  emit({ type: 'warning', detail: 'Objective-C runtime not available; is this an iOS app process?' });
} else {
  try {
    var bundleId = ObjC.classes.NSBundle.mainBundle().bundleIdentifier().toString();
    emit({ type: 'app.bundle', bundle_id: bundleId });
  } catch (e) {
    emit({ type: 'error', stage: 'bundle', error: String(e) });
  }

  try {
    var NSFileManager = ObjC.classes.NSFileManager;
    var contentsAtPath = NSFileManager['- contentsAtPath:'];
    Interceptor.attach(contentsAtPath.implementation, {
      onEnter: function (args) {
        emit({ type: 'fs.read', path: new ObjC.Object(args[2]).toString() });
      }
    });

    var createFile = NSFileManager['- createFileAtPath:contents:attributes:'];
    Interceptor.attach(createFile.implementation, {
      onEnter: function (args) {
        emit({ type: 'fs.write', path: new ObjC.Object(args[2]).toString() });
      }
    });

    emit({ type: 'hooks.installed', category: 'filesystem', ok: true });
  } catch (e) {
    emit({ type: 'error', stage: 'fs_hooks', error: String(e) });
  }

  try {
    var NSURLSession = ObjC.classes.NSURLSession;
    var dataTask = NSURLSession['- dataTaskWithRequest:completionHandler:'];
    Interceptor.attach(dataTask.implementation, {
      onEnter: function (args) {
        try {
          var req = new ObjC.Object(args[2]);
          var url = req.URL().absoluteString().toString();
          emit({ type: 'network.request', url: url });
        } catch (e) {
          emit({ type: 'error', stage: 'network_request', error: String(e) });
        }
      }
    });

    emit({ type: 'hooks.installed', category: 'network', ok: true });
  } catch (e) {
    emit({ type: 'error', stage: 'network_hooks', error: String(e) });
  }

  try {
    var CBCentralManager = ObjC.classes.CBCentralManager;
    var scan = CBCentralManager['- scanForPeripheralsWithServices:options:'];
    Interceptor.attach(scan.implementation, {
      onEnter: function (args) {
        emit({ type: 'bluetooth.scan', detail: 'scanForPeripheralsWithServices called' });
      }
    });

    emit({ type: 'hooks.installed', category: 'bluetooth', ok: true });
  } catch (e) {
    emit({ type: 'error', stage: 'bluetooth_hooks', error: String(e) });
  }
}
