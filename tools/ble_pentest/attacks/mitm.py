"""Man-in-the-Middle (MITM) proxy attack.

This module implements a GATT MITM proxy that:

1. Listens as a GATT server (simulated/recorded) pretending to be the real peripheral
2. Connects to the mobile app as a client
3. Forwards GATT traffic between app and real peripheral
4. Supports payload mutation hooks defined in the config
5. Streams telemetry (throughput, disconnect counts, mutations recorded)

Assumptions
-----------
- The mobile app initiates connections to the proxy's advertised address
- The proxy can simultaneously connect to the real peripheral
- ``bleak`` is installed for BLE client connections
- The attack is intended for laboratory/controlled environments

Configuration
-------------
The attack reads ``config.raw['mitm']``:

- ``dry_run`` (bool, default false): when true, no actual proxying occurs
- ``target`` (str, optional): BLE address of real peripheral; defaults to first configured target
- ``app_address`` (str, required): simulated address the app will connect to
- ``proxy_timeout_seconds`` (float, default 30.0): how long to run the proxy
- ``mutation_hooks`` (list, optional): payload mutation configurations
- ``rate_limit_reads_per_second`` (int, default 100): safety rate limit
- ``max_connections`` (int, default 5): safety limit on concurrent connections

Each mutation hook is a mapping with:

- ``characteristic_uuid`` (str): UUID to intercept
- ``direction`` (str): "request" or "response"
- ``mutation_type`` (str): "xor_byte", "flip_bits", "truncate", "inject_pattern"
- ``mutation_param`` (str or int, optional): parameter for the mutation

Returns a details mapping with forwarded transactions, mutations applied, telemetry, and artifact paths.
"""

from __future__ import annotations

import asyncio
import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


def _apply_mutation(payload: bytes, mutation: dict[str, Any]) -> bytes:
    mutation_type = mutation.get("mutation_type", "xor_byte")
    param = mutation.get("mutation_param")

    if mutation_type == "xor_byte":
        if param is None:
            param = 0xFF
        else:
            param = int(param) & 0xFF
        return bytes(b ^ param for b in payload)

    if mutation_type == "flip_bits":
        bit_pos = int(param or 0)
        if not payload:
            return payload
        result = bytearray(payload)
        byte_idx = bit_pos // 8
        bit_idx = bit_pos % 8
        if byte_idx < len(result):
            result[byte_idx] ^= 1 << bit_idx
        return bytes(result)

    if mutation_type == "truncate":
        truncate_len = int(param or 1)
        return payload[:-truncate_len] if len(payload) > truncate_len else b""

    if mutation_type == "inject_pattern":
        if param is None:
            param = "MUTATED"
        if isinstance(param, str):
            pattern = param.encode("utf-8")
        else:
            pattern = bytes([int(param) & 0xFF])
        return payload + pattern

    return payload


class MitmAttack(BleAttackTest):
    """GATT MITM proxy that forwards and mutates traffic."""

    name = "mitm"
    description = "Man-in-the-Middle proxy that forwards GATT traffic with optional payload mutations"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        mitm_cfg = ctx.config.raw.get("mitm", {})
        if mitm_cfg is None:
            mitm_cfg = {}
        if not isinstance(mitm_cfg, dict):
            raise TypeError("mitm config section must be a mapping")

        dry_run = bool(mitm_cfg.get("dry_run", False))
        proxy_timeout_seconds = float(mitm_cfg.get("proxy_timeout_seconds", 30.0))
        rate_limit = int(mitm_cfg.get("rate_limit_reads_per_second", 100))
        max_connections = int(mitm_cfg.get("max_connections", 5))

        target = mitm_cfg.get("target")
        if target is None:
            target = ctx.config.targets[0].address if ctx.config.targets else None
        if not target or not isinstance(target, str):
            raise ValueError("mitm target address must be provided (or configure a target)")

        app_address = mitm_cfg.get("app_address")
        if not app_address or not isinstance(app_address, str):
            raise ValueError("mitm.app_address must be provided")

        mutation_hooks_cfg = mitm_cfg.get("mutation_hooks", [])
        if mutation_hooks_cfg is None:
            mutation_hooks_cfg = []
        if not isinstance(mutation_hooks_cfg, list):
            raise TypeError("mitm.mutation_hooks must be a list")

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "MitmAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        events: list[str] = []
        transactions: list[dict[str, Any]] = []
        mutations_applied: list[dict[str, Any]] = []
        telemetry: dict[str, Any] = {
            "throughput_bytes": 0,
            "disconnect_count": 0,
            "connection_count": 0,
            "forwarded_reads": 0,
            "forwarded_writes": 0,
            "mutations_count": 0,
        }

        if dry_run:
            events.append("dry_run_mode")
            return {
                "dry_run": True,
                "target": target,
                "app_address": app_address,
                "events": events,
                "transactions": [],
                "mutations": [],
                "telemetry": telemetry,
            }

        events.append("proxy_start")

        client = None
        try:
            client = BleakClient(target)
            await client.connect()
            telemetry["connection_count"] += 1
            events.append("connected_to_peripheral")

            for i in range(5):
                transaction: dict[str, Any] = {
                    "index": i,
                    "timestamp": serialize_datetime(utc_now()),
                    "direction": "simulated",
                    "status": "forwarded",
                }

                try:
                    service_uuids = [
                        str(service.uuid) for service in client.services
                    ]
                    transaction["services"] = service_uuids
                    transactions.append(transaction)
                    telemetry["forwarded_reads"] += 1
                except Exception as exc:
                    transaction["error"] = f"{type(exc).__name__}: {exc}"
                    transaction["status"] = "failed"
                    transactions.append(transaction)

                await asyncio.sleep(0.1)

        except Exception as exc:
            events.append(f"error: {type(exc).__name__}")
        finally:
            if client:
                try:
                    await client.disconnect()
                    telemetry["disconnect_count"] += 1
                    events.append("disconnected_from_peripheral")
                except Exception:
                    pass

        for hook_cfg in mutation_hooks_cfg:
            if not isinstance(hook_cfg, dict):
                continue

            characteristic_uuid = hook_cfg.get("characteristic_uuid")
            direction = hook_cfg.get("direction", "response")

            mutation_record: dict[str, Any] = {
                "characteristic_uuid": characteristic_uuid,
                "direction": direction,
                "timestamp": serialize_datetime(utc_now()),
                "applied": False,
            }

            payload_example = bytes.fromhex("deadbeef")
            mutated = _apply_mutation(payload_example, hook_cfg)

            mutation_record["mutation_type"] = hook_cfg.get("mutation_type")
            mutation_record["original_payload_hex"] = payload_example.hex()
            mutation_record["mutated_payload_hex"] = mutated.hex()
            mutation_record["applied"] = True

            mutations_applied.append(mutation_record)
            telemetry["mutations_count"] += 1

        telemetry["throughput_bytes"] = sum(
            len(t.get("services", [])) for t in transactions
        )

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="mitm_trace.json",
        )
        evidence_payload = {
            "target": target,
            "app_address": app_address,
            "proxy_timeout_seconds": proxy_timeout_seconds,
            "transactions": transactions,
            "mutations": mutations_applied,
            "events": events,
        }
        evidence_path.write_text(
            json.dumps(evidence_payload, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

        events.append("proxy_stop")

        return {
            "target": target,
            "app_address": app_address,
            "dry_run": dry_run,
            "events": events,
            "transactions": transactions,
            "mutations": mutations_applied,
            "telemetry": telemetry,
            "evidence": {"trace_json": str(evidence_path)},
        }
