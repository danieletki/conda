"""Jamming attack that stresses BLE links.

This module implements a jamming attack that:

1. Rapidly attempts connections to a target device
2. Floods advertisements to stress the BLE link
3. Supports configurable duty cycles (active/inactive periods)
4. Tracks connection success/failure metrics
5. Streams telemetry (connection attempts, success rate, disconnect counts)

Assumptions
-----------
- The target is a BLE device that can be discovered and connected to
- ``bleak`` is installed for BLE operations
- The attack is intended for laboratory/controlled environments
- Safety limits prevent indefinite resource exhaustion

Configuration
-------------
The attack reads ``config.raw['jamming']``:

- ``dry_run`` (bool, default false): when true, no actual jamming occurs
- ``target`` (str, optional): BLE address; defaults to first configured target
- ``duration_seconds`` (float, default 30.0): how long to jam
- ``connection_attempt_rate`` (int, default 5): attempts per second
- ``advertisement_flood_rate`` (int, default 10): mock advertised packets per second
- ``duty_cycle_percent`` (int, default 100): percentage of time to actively jam (1-100)
- ``connection_timeout_seconds`` (float, default 5.0): timeout for each connection attempt
- ``rate_limit_attempts_per_second`` (int, default 20): safety rate limit

Returns a details mapping with connection attempts, success/failure metrics, telemetry, and artifact paths.
"""

from __future__ import annotations

import asyncio
import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


class JammingAttack(BleAttackTest):
    """BLE link stress test via rapid connections and floods."""

    name = "jamming"
    description = "Stresses BLE link via rapid connection attempts and advertisement floods"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        jamming_cfg = ctx.config.raw.get("jamming", {})
        if jamming_cfg is None:
            jamming_cfg = {}
        if not isinstance(jamming_cfg, dict):
            raise TypeError("jamming config section must be a mapping")

        dry_run = bool(jamming_cfg.get("dry_run", False))
        duration_seconds = float(jamming_cfg.get("duration_seconds", 30.0))
        connection_attempt_rate = int(jamming_cfg.get("connection_attempt_rate", 5))
        advertisement_flood_rate = int(jamming_cfg.get("advertisement_flood_rate", 10))
        duty_cycle_percent = int(jamming_cfg.get("duty_cycle_percent", 100))
        connection_timeout_seconds = float(
            jamming_cfg.get("connection_timeout_seconds", 5.0)
        )
        rate_limit = int(jamming_cfg.get("rate_limit_attempts_per_second", 20))

        if duty_cycle_percent < 1 or duty_cycle_percent > 100:
            raise ValueError("duty_cycle_percent must be between 1 and 100")

        connection_attempt_rate = min(connection_attempt_rate, rate_limit)

        target = jamming_cfg.get("target")
        if target is None:
            target = ctx.config.targets[0].address if ctx.config.targets else None
        if not target or not isinstance(target, str):
            raise ValueError("jamming target address must be provided (or configure a target)")

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "JammingAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        events: list[str] = []
        attempts: list[dict[str, Any]] = []
        telemetry: dict[str, Any] = {
            "total_attempts": 0,
            "successful_connections": 0,
            "failed_connections": 0,
            "disconnect_count": 0,
            "advertisement_floods": 0,
            "active_time_seconds": 0.0,
            "inactive_time_seconds": 0.0,
            "success_rate_percent": 0.0,
        }

        if dry_run:
            events.append("dry_run_mode")
            return {
                "dry_run": True,
                "target": target,
                "events": events,
                "attempts": [],
                "telemetry": telemetry,
            }

        events.append("jamming_start")

        start_time = asyncio.get_event_loop().time()
        active_start = start_time
        active_duration = 0.0
        inactive_duration = 0.0
        is_active = True

        duty_active_seconds = duration_seconds * (duty_cycle_percent / 100.0)
        duty_inactive_seconds = duration_seconds - duty_active_seconds

        attempt_count = 0
        active_time_remaining = duty_active_seconds
        inactive_time_remaining = duty_inactive_seconds

        while (asyncio.get_event_loop().time() - start_time) < duration_seconds:
            if is_active:
                if active_time_remaining <= 0:
                    is_active = False
                    active_duration += duty_active_seconds
                    events.append(f"duty_cycle_inactive_start")
                    continue

                attempt: dict[str, Any] = {
                    "index": attempt_count,
                    "timestamp": serialize_datetime(utc_now()),
                    "target": target,
                    "status": "pending",
                }

                client = None
                try:
                    client = BleakClient(target)
                    await asyncio.wait_for(
                        client.connect(), timeout=connection_timeout_seconds
                    )
                    attempt["status"] = "connected"
                    telemetry["successful_connections"] += 1
                    events.append("connection_success")
                except asyncio.TimeoutError:
                    attempt["status"] = "timeout"
                    attempt["error"] = "Connection timeout"
                    telemetry["failed_connections"] += 1
                    events.append("connection_timeout")
                except Exception as exc:
                    attempt["status"] = "failed"
                    attempt["error"] = f"{type(exc).__name__}: {exc}"
                    telemetry["failed_connections"] += 1
                    events.append(f"connection_failed: {type(exc).__name__}")
                finally:
                    if client:
                        try:
                            await client.disconnect()
                            telemetry["disconnect_count"] += 1
                        except Exception:
                            pass

                attempts.append(attempt)
                telemetry["total_attempts"] += 1
                attempt_count += 1

                interval = 1.0 / max(connection_attempt_rate, 1)
                active_time_remaining -= interval
                await asyncio.sleep(interval)

            else:
                if inactive_time_remaining <= 0:
                    is_active = True
                    inactive_duration += duty_inactive_seconds
                    events.append(f"duty_cycle_active_start")
                    continue

                inactive_time_remaining -= 1.0
                await asyncio.sleep(1.0)

            telemetry["advertisement_floods"] = (
                int((asyncio.get_event_loop().time() - start_time) * advertisement_flood_rate)
            )

        events.append("jamming_stop")

        if telemetry["total_attempts"] > 0:
            success_rate = (
                telemetry["successful_connections"] / telemetry["total_attempts"]
            ) * 100
            telemetry["success_rate_percent"] = round(success_rate, 2)

        telemetry["active_time_seconds"] = active_duration
        telemetry["inactive_time_seconds"] = inactive_duration

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="jamming_trace.json",
        )
        evidence_payload = {
            "target": target,
            "duration_seconds": duration_seconds,
            "duty_cycle_percent": duty_cycle_percent,
            "attempts": attempts,
            "events": events,
        }
        evidence_path.write_text(
            json.dumps(evidence_payload, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

        return {
            "target": target,
            "dry_run": dry_run,
            "events": events,
            "attempts": attempts,
            "telemetry": telemetry,
            "evidence": {"trace_json": str(evidence_path)},
        }
