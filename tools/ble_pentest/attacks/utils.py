"""Shared helpers for BLE pentest attacks.

The harness is intentionally lightweight, so these helpers focus on:

- decoding YAML-friendly payload representations (hex/base64/utf-8)
- basic heuristics for flagging likely cleartext advertisement payloads
- writing evidence artifacts in a deterministic location

None of these helpers require ``bleak``.
"""

from __future__ import annotations

import base64
import json
import math
from datetime import datetime, timezone
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any


def utc_now() -> datetime:
    return datetime.now(tz=timezone.utc)


def serialize_datetime(value: datetime) -> str:
    return value.astimezone(timezone.utc).isoformat()


def bytes_to_hex(data: bytes) -> str:
    return data.hex()


def decode_payload(mapping: dict[str, Any]) -> bytes:
    """Decode a payload mapping into bytes.

    Supported keys (first match wins):

    - ``value_hex``: hex-encoded string, e.g. "deadbeef"
    - ``value_base64``: base64 encoded string
    - ``value_utf8``: plain string that will be utf-8 encoded

    Parameters
    ----------
    mapping:
        YAML-derived mapping containing one of the supported payload keys.

    Returns
    -------
    bytes
        The decoded payload.
    """

    if "value_hex" in mapping:
        value = mapping["value_hex"]
        if not isinstance(value, str):
            raise TypeError("value_hex must be a string")
        return bytes.fromhex(value)

    if "value_base64" in mapping:
        value = mapping["value_base64"]
        if not isinstance(value, str):
            raise TypeError("value_base64 must be a string")
        return base64.b64decode(value)

    if "value_utf8" in mapping:
        value = mapping["value_utf8"]
        if not isinstance(value, str):
            raise TypeError("value_utf8 must be a string")
        return value.encode("utf-8")

    raise KeyError(
        "payload mapping must include value_hex, value_base64, or value_utf8"
    )


def shannon_entropy(data: bytes) -> float:
    if not data:
        return 0.0
    counts: dict[int, int] = {}
    for b in data:
        counts[b] = counts.get(b, 0) + 1
    entropy = 0.0
    length = len(data)
    for count in counts.values():
        p = count / length
        entropy -= p * math.log2(p)
    return entropy


def looks_like_cleartext(data: bytes, *, entropy_threshold: float = 4.0) -> bool:
    """Heuristic for flagging likely cleartext payload bytes.

    BLE advertising data frequently contains opaque bytes even when the link layer
    is encrypted. This function intentionally uses *weak* heuristics: it is meant
    to surface candidates for analyst review, not to definitively classify
    cryptographic protection.

    The default checks are:

    - at least 70% printable ASCII characters (including whitespace)
    - and low Shannon entropy (below ``entropy_threshold``)
    """

    if not data:
        return False

    printable = sum(1 for b in data if 32 <= b <= 126 or b in (9, 10, 13))
    ratio = printable / len(data)
    if ratio < 0.7:
        return False

    return shannon_entropy(data) <= entropy_threshold


def safe_decode_utf8(data: bytes) -> str | None:
    try:
        return data.decode("utf-8")
    except UnicodeDecodeError:
        return None


def artifact_path(
    output_dir: str | Path, *, run_id: str, attack: str, filename: str
) -> Path:
    """Return a deterministic artifact path.

    Artifacts are written under ``<output_dir>/artifacts/<attack>/``.
    """

    output_dir = Path(output_dir)
    attack_dir = output_dir / "artifacts" / attack
    attack_dir.mkdir(parents=True, exist_ok=True)
    return attack_dir / f"{run_id}_{filename}"


def write_jsonl(path: str | Path, rows: list[dict[str, Any]]) -> None:
    path = Path(path)
    path.write_text(
        "".join(json.dumps(row, sort_keys=True) + "\n" for row in rows),
        encoding="utf-8",
    )
