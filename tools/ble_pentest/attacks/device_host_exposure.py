"""Device host exposure test using Frida instrumentation.

The goal of this test is to surface *mobile app* behaviors that expand the attack
surface of a BLE deployment:

- permissions granted to the app (Android)
- filesystem access patterns
- network activity initiated by the app
- usage of Bluetooth APIs (scan/connect/write)

This attack relies on Frida to instrument the app process.

Configuration
-------------
The attack reads ``config.raw['device_host_exposure']``:

- ``platform`` (str, required): ``"android"`` or ``"ios"``.
- ``package_id`` (str, required): Android application ID or iOS bundle ID.
- ``endpoint`` (str, optional): Frida device selector.

  - ``"usb"`` (default): use ``frida.get_usb_device``.
  - ``"local"``: use ``frida.get_local_device``.
  - otherwise treated as ``host:port`` for ``add_remote_device``.

- ``timeout_seconds`` (float, default 5.0): device discovery/attach timeout.
- ``duration_seconds`` (float, default 0.0): time to wait after script load while
  collecting events.

A global ``config.raw['frida']`` mapping may provide defaults for ``endpoint`` and
``timeout_seconds``.

Platform tooling prerequisites
------------------------------
- Install Frida and frida-tools.
- Ensure a matching frida-server is running on the target device.

Android notes:
- Most workflows require a rooted emulator/device to run frida-server.
- You may need to forward the server port: ``adb forward tcp:27042 tcp:27042``.

iOS notes:
- Requires a jailbroken device or alternative instrumentation-friendly setup.
"""

from __future__ import annotations

import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .frida_helpers import FridaConnectionConfig, collect_events, load_script
from .utils import artifact_path

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


_ANDROID_DANGEROUS_PERMISSIONS = {
    "android.permission.READ_SMS",
    "android.permission.RECEIVE_SMS",
    "android.permission.SEND_SMS",
    "android.permission.READ_CONTACTS",
    "android.permission.WRITE_CONTACTS",
    "android.permission.READ_CALL_LOG",
    "android.permission.WRITE_CALL_LOG",
    "android.permission.RECORD_AUDIO",
    "android.permission.CAMERA",
    "android.permission.ACCESS_FINE_LOCATION",
    "android.permission.ACCESS_COARSE_LOCATION",
    "android.permission.READ_EXTERNAL_STORAGE",
    "android.permission.WRITE_EXTERNAL_STORAGE",
}


def _get_frida_defaults(raw: dict[str, Any]) -> dict[str, Any]:
    frida_cfg = raw.get("frida", {})
    if frida_cfg is None:
        frida_cfg = {}
    if not isinstance(frida_cfg, dict):
        raise TypeError("frida config section must be a mapping")
    return frida_cfg


def _summarize_events(platform: str, events: list[dict[str, Any]]):
    permissions: list[dict[str, Any]] = []
    fs_events: list[dict[str, Any]] = []
    network_events: list[dict[str, Any]] = []
    bluetooth_events: list[dict[str, Any]] = []

    for event in events:
        event_type = event.get("type")
        if not isinstance(event_type, str):
            continue

        if platform == "android" and event_type == "android.permission":
            permissions.append(event)
            continue

        if event_type.startswith("fs."):
            fs_events.append(event)
            continue

        if event_type.startswith("network."):
            network_events.append(event)
            continue

        if event_type.startswith("bluetooth."):
            bluetooth_events.append(event)
            continue

    return {
        "permissions": permissions,
        "filesystem": fs_events,
        "network": network_events,
        "bluetooth": bluetooth_events,
    }


def _build_findings(platform: str, summary: dict[str, Any]) -> list[dict[str, Any]]:
    findings: list[dict[str, Any]] = []

    if platform == "android":
        granted = [
            p.get("name")
            for p in summary["permissions"]
            if p.get("granted") is True and isinstance(p.get("name"), str)
        ]
        for perm in sorted(set(granted)):
            if perm in _ANDROID_DANGEROUS_PERMISSIONS:
                findings.append(
                    {
                        "type": "dangerous_permission_granted",
                        "permission": perm,
                        "detail": "App has a high-risk Android permission; validate least-privilege and runtime gating.",
                    }
                )

    if summary["filesystem"]:
        findings.append(
            {
                "type": "filesystem_access_observed",
                "count": len(summary["filesystem"]),
                "detail": "Instrumented app opened files; verify secrets are encrypted at rest and paths are not world-readable.",
            }
        )

    if summary["network"]:
        findings.append(
            {
                "type": "network_access_observed",
                "count": len(summary["network"]),
                "detail": "Instrumented app initiated network activity; confirm TLS enforcement and avoid leaking BLE identifiers.",
            }
        )

    if summary["bluetooth"]:
        findings.append(
            {
                "type": "bluetooth_api_usage_observed",
                "count": len(summary["bluetooth"]),
                "detail": "Instrumented app called Bluetooth APIs; validate pairing/bonding requirements and avoid sensitive data over unauthenticated characteristics.",
            }
        )

    return findings


class DeviceHostExposureAttack(BleAttackTest):
    name = "device_host_exposure"
    description = "Uses Frida to enumerate app permissions and observe filesystem/network/Bluetooth API usage"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        raw = ctx.config.raw
        attack_cfg = raw.get("device_host_exposure", {})
        if attack_cfg is None:
            attack_cfg = {}
        if not isinstance(attack_cfg, dict):
            raise TypeError("device_host_exposure config section must be a mapping")

        platform = attack_cfg.get("platform")
        if not platform or not isinstance(platform, str):
            raise ValueError("device_host_exposure.platform must be provided")
        platform = platform.strip().lower()
        if platform not in {"android", "ios"}:
            raise ValueError("device_host_exposure.platform must be 'android' or 'ios'")

        package_id = attack_cfg.get("package_id")
        if not package_id or not isinstance(package_id, str):
            raise ValueError("device_host_exposure.package_id must be provided")

        frida_defaults = _get_frida_defaults(raw)
        endpoint = attack_cfg.get("endpoint", frida_defaults.get("endpoint"))
        timeout_seconds = float(
            attack_cfg.get(
                "timeout_seconds", frida_defaults.get("timeout_seconds", 5.0)
            )
        )
        duration_seconds = float(attack_cfg.get("duration_seconds", 0.0))

        script_name = (
            "android_device_host_exposure.js"
            if platform == "android"
            else "ios_device_host_exposure.js"
        )
        script_source = load_script(script_name)

        events, errors = await collect_events(
            connection=FridaConnectionConfig(
                endpoint=endpoint, timeout_seconds=timeout_seconds
            ),
            target=package_id,
            script_source=script_source,
            duration_seconds=duration_seconds,
        )

        summary = _summarize_events(platform, events)
        findings = _build_findings(platform, summary)

        remediation: list[dict[str, Any]] = [
            {
                "title": "Apply least privilege",
                "detail": "Remove unused permissions/capabilities, and gate sensitive operations behind explicit user interaction.",
            },
            {
                "title": "Harden local storage",
                "detail": "Store tokens/keys in platform keystores (Android Keystore / iOS Keychain) and encrypt sensitive files.",
            },
            {
                "title": "Secure networking",
                "detail": "Enforce TLS with certificate validation/pinning where appropriate and avoid transmitting stable BLE identifiers.",
            },
            {
                "title": "Constrain BLE operations",
                "detail": "Require pairing/bonding for privileged characteristics and validate authorization state in both app and device firmware.",
            },
        ]

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename=f"{platform}_frida_events.json",
        )
        evidence_path.write_text(
            json.dumps(
                {
                    "platform": platform,
                    "package_id": package_id,
                    "endpoint": endpoint,
                    "events": events,
                    "errors": errors,
                },
                indent=2,
                sort_keys=True,
            )
            + "\n",
            encoding="utf-8",
        )

        return {
            "platform": platform,
            "package_id": package_id,
            "endpoint": endpoint,
            "events": events,
            "errors": errors,
            "summary": summary,
            "findings": findings,
            "remediation": remediation,
            "evidence": {"frida_events_json": str(evidence_path)},
        }
