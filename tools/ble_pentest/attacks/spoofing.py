"""Advertisement/attribute spoofing helpers.

BLE "spoofing" can mean several things (address randomisation, advertising under
another identity, forging GATT writes, etc.). This implementation focuses on two
operator-friendly primitives:

1. **Advertisement spoofing (simulated)**: record an intention to transmit a
   crafted advertisement.
2. **Characteristic write spoofing (active)**: connect to a target and issue
   configured GATT writes.

Because ``bleak`` does not provide a cross-platform way to transmit arbitrary BLE
advertisements, the advertisement spoofing portion is recorded as an *artifact*
for analyst review and to keep the harness portable.

Configuration
-------------
The attack reads ``config.raw['spoofing']``:

- ``dry_run`` (bool, default false): when true, no BLE operations are executed.
- ``actions`` (list): sequence of spoofing actions.

Each action is a mapping with a required ``type`` key:

- ``type: write``
    - ``target`` (str, optional): BLE address; defaults to the first configured target.
    - ``characteristic_uuid`` (str): UUID of characteristic to write.
    - one of ``value_hex``, ``value_base64``, ``value_utf8``
    - ``response`` (bool, default true): request write-with-response.

- ``type: advertisement``
    - ``local_name`` (str, optional)
    - ``manufacturer_data_hex`` (mapping[int,str], optional)
    - ``service_data_hex`` (mapping[str,str], optional)

Returns a details mapping with executed actions, findings, and artifact paths.
"""

from __future__ import annotations

import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, decode_payload, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


def _hex_mapping(value: Any) -> dict[Any, bytes]:
    if value is None:
        return {}
    if not isinstance(value, dict):
        raise TypeError("expected a mapping")
    decoded: dict[Any, bytes] = {}
    for key, item in value.items():
        if not isinstance(item, str):
            raise TypeError("hex mapping values must be strings")
        decoded[key] = bytes.fromhex(item)
    return decoded


class SpoofingAttack(BleAttackTest):
    """Replay crafted advertisements and/or GATT writes."""

    name = "spoofing"
    description = "Replays crafted advertisements (simulated) and characteristic writes"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        spoofing_cfg = ctx.config.raw.get("spoofing", {})
        if spoofing_cfg is None:
            spoofing_cfg = {}
        if not isinstance(spoofing_cfg, dict):
            raise TypeError("spoofing config section must be a mapping")

        dry_run = bool(spoofing_cfg.get("dry_run", False))
        actions_cfg = spoofing_cfg.get("actions", [])
        if actions_cfg is None:
            actions_cfg = []
        if not isinstance(actions_cfg, list):
            raise TypeError("spoofing.actions must be a list")

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "SpoofingAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        default_target = ctx.config.targets[0].address if ctx.config.targets else None

        findings: list[dict[str, Any]] = []
        executed: list[dict[str, Any]] = []

        for index, action in enumerate(actions_cfg):
            if not isinstance(action, dict):
                raise TypeError("each spoofing action must be a mapping")

            action_type = action.get("type")
            if action_type not in {"write", "advertisement"}:
                raise ValueError(f"unsupported spoofing action type: {action_type!r}")

            record: dict[str, Any] = {
                "index": index,
                "type": action_type,
                "timestamp": serialize_datetime(utc_now()),
            }

            if action_type == "advertisement":
                record["local_name"] = action.get("local_name")
                manufacturer = _hex_mapping(action.get("manufacturer_data_hex"))
                service_data = _hex_mapping(action.get("service_data_hex"))
                record["manufacturer_data_hex"] = {
                    str(k): v.hex() for k, v in manufacturer.items()
                }
                record["service_data_hex"] = {
                    str(k): v.hex() for k, v in service_data.items()
                }
                record["supported"] = False
                findings.append(
                    {
                        "type": "advertisement_spoofing_unsupported",
                        "detail": "bleak does not support transmitting arbitrary advertisements; action recorded as artifact",
                    }
                )
                executed.append(record)
                continue

            target = action.get("target") or default_target
            if not target or not isinstance(target, str):
                raise ValueError("spoofing write actions require a target address")

            characteristic_uuid = action.get("characteristic_uuid")
            if not characteristic_uuid or not isinstance(characteristic_uuid, str):
                raise ValueError("spoofing write actions require characteristic_uuid")

            response = action.get("response")
            response = True if response is None else bool(response)

            payload = decode_payload(action)

            record.update(
                {
                    "target": target,
                    "characteristic_uuid": characteristic_uuid,
                    "payload_hex": payload.hex(),
                    "response": response,
                }
            )

            if dry_run:
                record["status"] = "dry_run"
                executed.append(record)
                continue

            client = BleakClient(target)
            try:
                await client.connect()
                await client.write_gatt_char(
                    characteristic_uuid, payload, response=response
                )
                record["status"] = "written"
            except Exception as exc:  # noqa: BLE001
                record["status"] = "error"
                record["error"] = f"{type(exc).__name__}: {exc}"
                findings.append(
                    {
                        "type": "write_failed",
                        "target": target,
                        "characteristic_uuid": characteristic_uuid,
                        "error": record["error"],
                    }
                )
            finally:
                try:
                    await client.disconnect()
                except Exception:  # noqa: BLE001
                    pass

            executed.append(record)

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="spoofing_actions.json",
        )
        evidence_path.write_text(
            json.dumps(executed, indent=2, sort_keys=True) + "\n",
            encoding="utf-8",
        )

        return {
            "dry_run": dry_run,
            "actions": executed,
            "findings": findings,
            "evidence": {"actions_json": str(evidence_path)},
        }
