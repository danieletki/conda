"""Privilege escalation test for BLE GATT control characteristics.

This attack focuses on *active fuzzing* of a control characteristic that is
expected to enforce authorization checks (pairing/bonding, application-layer
authentication, role-based access control, etc.).

The harness will generate boundary-value payloads and attempt GATT writes/reads.
If privileged opcodes are accepted or non-empty responses are returned without an
explicit authentication step, the attack records a finding for analyst review.

Configuration
-------------
The attack reads ``config.raw['privilege_escalation']``:

- ``target`` (str, optional): BLE address; defaults to the first configured target.
- ``characteristic_uuid`` (str, required): control characteristic to fuzz.
- ``response_characteristic_uuid`` (str, optional): characteristic to read after a
  write. Defaults to ``characteristic_uuid``.
- ``write_response`` (bool, default true): request write-with-response.
- ``delay_seconds`` (float, default 0.0): delay between fuzz cases.

Fuzzing bounds:

- ``min_value`` (int, default 0): minimum integer boundary value.
- ``max_value`` (int, default 255): maximum integer boundary value.
- ``value_size`` (int, default 1): number of bytes used to encode the fuzzed
  value (little-endian).
- ``opcodes`` (list[int|str], optional): list of control opcodes to test. String
  values may be decimal ("10") or hex ("0x0a").
- ``privileged_opcodes`` (list[int|str], optional): opcodes that are expected to
  be rejected unless authenticated; if accepted, a finding is emitted.
- ``max_cases`` (int, default 128): safety bound for the total number of cases.

Notes
-----
This attack does not attempt to infer the device's application protocol.
Findings are heuristic: they are intended to highlight *candidates* for deeper
analysis.

Tooling prerequisites
---------------------
- Requires ``bleak`` (install tools/ble_pentest/requirements-ble.txt)
"""

from __future__ import annotations

import asyncio
import json
from typing import TYPE_CHECKING

from ..base import BleAttackTest
from .utils import artifact_path, serialize_datetime, utc_now

if TYPE_CHECKING:
    from typing import Any

    from ..base import AttackContext


def _parse_int(value: Any) -> int:
    if isinstance(value, int):
        return value
    if isinstance(value, str):
        value = value.strip().lower()
        base = 16 if value.startswith("0x") else 10
        return int(value, base=base)
    raise TypeError(f"expected int or str, got {type(value)!r}")


def _boundary_values(min_value: int, max_value: int) -> list[int]:
    if min_value > max_value:
        min_value, max_value = max_value, min_value

    candidates = [
        min_value,
        min_value + 1,
        0,
        1,
        0x7F,
        0x80,
        0xFF,
        max_value - 1,
        max_value,
    ]

    deduped: list[int] = []
    for cand in candidates:
        if cand < min_value or cand > max_value:
            continue
        if cand not in deduped:
            deduped.append(cand)
    return deduped


class PrivilegeEscalationAttack(BleAttackTest):
    name = "privilege_escalation"
    description = "Fuzzes GATT control commands/boundary values and flags responses that may indicate missing authorization"

    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        cfg = ctx.config.raw.get("privilege_escalation", {})
        if cfg is None:
            cfg = {}
        if not isinstance(cfg, dict):
            raise TypeError("privilege_escalation config section must be a mapping")

        characteristic_uuid = cfg.get("characteristic_uuid")
        if not characteristic_uuid or not isinstance(characteristic_uuid, str):
            raise ValueError(
                "privilege_escalation.characteristic_uuid must be provided"
            )

        response_uuid = cfg.get("response_characteristic_uuid")
        if response_uuid is None:
            response_uuid = characteristic_uuid
        if not isinstance(response_uuid, str):
            raise TypeError(
                "privilege_escalation.response_characteristic_uuid must be a string"
            )

        target = cfg.get("target")
        if target is None:
            target = ctx.config.targets[0].address if ctx.config.targets else None
        if not target or not isinstance(target, str):
            raise ValueError(
                "privilege_escalation.target must be provided (or configure a target)"
            )

        write_response = bool(cfg.get("write_response", True))
        delay_seconds = float(cfg.get("delay_seconds", 0.0))

        min_value = int(cfg.get("min_value", 0))
        max_value = int(cfg.get("max_value", 255))
        value_size = int(cfg.get("value_size", 1))
        if value_size <= 0 or value_size > 8:
            raise ValueError("privilege_escalation.value_size must be between 1 and 8")

        opcodes_raw = cfg.get("opcodes", [0])
        if opcodes_raw is None:
            opcodes_raw = [0]
        if not isinstance(opcodes_raw, list):
            raise TypeError("privilege_escalation.opcodes must be a list")
        opcodes = [_parse_int(v) & 0xFF for v in opcodes_raw]

        privileged_raw = cfg.get("privileged_opcodes", [])
        if privileged_raw is None:
            privileged_raw = []
        if not isinstance(privileged_raw, list):
            raise TypeError("privilege_escalation.privileged_opcodes must be a list")
        privileged = {_parse_int(v) & 0xFF for v in privileged_raw}

        max_cases = int(cfg.get("max_cases", 128))

        try:
            from bleak import BleakClient  # type: ignore[import-not-found]
        except ModuleNotFoundError as exc:  # pragma: no cover
            raise RuntimeError(
                "PrivilegeEscalationAttack requires bleak. Install tools/ble_pentest/requirements-ble.txt"
            ) from exc

        events: list[str] = []
        cases: list[dict[str, Any]] = []
        findings: list[dict[str, Any]] = []

        fuzz_values = _boundary_values(min_value, max_value)

        planned = len(opcodes) * len(fuzz_values)
        if planned > max_cases:
            findings.append(
                {
                    "type": "case_limit_reached",
                    "detail": f"Planned {planned} fuzz cases but max_cases={max_cases}; truncating.",
                }
            )

        client = BleakClient(target)
        await client.connect()
        events.append("connected")
        try:
            case_index = 0
            for opcode in opcodes:
                for value in fuzz_values:
                    if case_index >= max_cases:
                        break

                    payload = bytes([opcode]) + int(value).to_bytes(
                        value_size, byteorder="little", signed=False
                    )
                    record: dict[str, Any] = {
                        "index": case_index,
                        "opcode": opcode,
                        "value": value,
                        "payload_hex": payload.hex(),
                        "timestamp": serialize_datetime(utc_now()),
                        "status": "pending",
                    }

                    try:
                        await client.write_gatt_char(
                            characteristic_uuid, payload, response=write_response
                        )
                        record["status"] = "write_accepted"
                    except Exception as exc:  # noqa: BLE001
                        record["status"] = "write_rejected"
                        record["error"] = f"{type(exc).__name__}: {exc}"

                    response_hex = None
                    if record["status"] == "write_accepted":
                        try:
                            response = await client.read_gatt_char(response_uuid)
                            if isinstance(response, bytearray):
                                response = bytes(response)
                            if isinstance(response, (bytes, bytearray)):
                                response_hex = bytes(response).hex()
                        except Exception as exc:  # noqa: BLE001
                            record["read_error"] = f"{type(exc).__name__}: {exc}"

                    if response_hex is not None:
                        record["response_hex"] = response_hex

                    if (
                        record["status"] == "write_accepted"
                        and privileged
                        and opcode in privileged
                    ):
                        findings.append(
                            {
                                "type": "privileged_opcode_accepted",
                                "opcode": opcode,
                                "payload_hex": record["payload_hex"],
                                "detail": "A privileged opcode was accepted; verify authorization is enforced server-side.",
                            }
                        )

                    if record.get("response_hex"):
                        findings.append(
                            {
                                "type": "control_command_response_observed",
                                "opcode": opcode,
                                "payload_hex": record["payload_hex"],
                                "response_hex": record.get("response_hex"),
                                "detail": "Non-empty response observed; confirm sensitive operations require authentication.",
                            }
                        )

                    cases.append(record)
                    case_index += 1

                    if delay_seconds > 0:
                        await asyncio.sleep(delay_seconds)
        finally:
            events.append("disconnect")
            await client.disconnect()

        evidence_path = artifact_path(
            ctx.report_writer.output_dir,
            run_id=ctx.report_writer.run_id,
            attack=self.name,
            filename="fuzz_cases.json",
        )
        evidence_path.write_text(
            json.dumps(
                {
                    "target": target,
                    "characteristic_uuid": characteristic_uuid,
                    "response_characteristic_uuid": response_uuid,
                    "cases": cases,
                    "events": events,
                },
                indent=2,
                sort_keys=True,
            )
            + "\n",
            encoding="utf-8",
        )

        remediation: list[dict[str, Any]] = [
            {
                "title": "Enforce authorization on control characteristics",
                "detail": "Require pairing/bonding and validate an authenticated session before executing privileged opcodes.",
            },
            {
                "title": "Validate opcode and payload bounds",
                "detail": "Reject unknown opcodes/lengths and implement explicit bounds checks to prevent memory corruption and logic bypasses.",
            },
            {
                "title": "Apply rate limiting and lockout",
                "detail": "Throttle repeated invalid control requests to reduce brute-force and fuzzing risk.",
            },
        ]

        return {
            "target": target,
            "characteristic_uuid": characteristic_uuid,
            "response_characteristic_uuid": response_uuid,
            "events": events,
            "bounds": {
                "min_value": min_value,
                "max_value": max_value,
                "value_size": value_size,
                "opcodes": opcodes,
                "privileged_opcodes": sorted(privileged),
                "max_cases": max_cases,
            },
            "cases": cases,
            "findings": findings,
            "remediation": remediation,
            "evidence": {"fuzz_cases_json": str(evidence_path)},
        }
