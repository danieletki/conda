"""Base abstractions for BLE pentest attack implementations."""

from __future__ import annotations

import asyncio
from abc import ABC, abstractmethod
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import TYPE_CHECKING

from .reports import AttackResult

if TYPE_CHECKING:
    from collections.abc import Iterable, Sequence
    from typing import Any, ClassVar

    from .config import BlePentestConfig
    from .reports import ReportWriter


@dataclass(frozen=True)
class AttackContext:
    config: BlePentestConfig
    report_writer: ReportWriter


class BleAttackTest(ABC):
    name: ClassVar[str]
    description: ClassVar[str] = ""

    async def setup(self, ctx: AttackContext) -> None:
        return None

    @abstractmethod
    async def run(self, ctx: AttackContext) -> dict[str, Any]:
        raise NotImplementedError

    async def teardown(self, ctx: AttackContext) -> None:
        return None

    async def execute(self, ctx: AttackContext) -> AttackResult:
        started_at = datetime.now(tz=timezone.utc)

        try:
            await self.setup(ctx)
            details = await self.run(ctx)
            if details is None:
                details = {}
            result = AttackResult(attack=self.name, success=True, details=dict(details))
        except Exception as exc:
            result = AttackResult(
                attack=self.name,
                success=False,
                details={},
                error=f"{type(exc).__name__}: {exc}",
            )
        finally:
            try:
                await self.teardown(ctx)
            except Exception as exc:
                result = AttackResult(
                    attack=self.name,
                    success=False,
                    details=result.details,
                    error=f"TeardownError({type(exc).__name__}): {exc}",
                )

        finished_at = datetime.now(tz=timezone.utc)
        return AttackResult(
            attack=result.attack,
            success=result.success,
            details=result.details,
            error=result.error,
            started_at=started_at,
            finished_at=finished_at,
        )


async def run_attacks(
    attacks: Sequence[BleAttackTest],
    *,
    config: BlePentestConfig,
    report_writer: ReportWriter,
    concurrent: bool = False,
) -> list[AttackResult]:
    ctx = AttackContext(config=config, report_writer=report_writer)

    if not concurrent:
        results: list[AttackResult] = []
        for attack in attacks:
            results.append(await attack.execute(ctx))
        return results

    tasks = [asyncio.create_task(attack.execute(ctx)) for attack in attacks]
    return list(await asyncio.gather(*tasks))


def run_coroutine_sync(coro: Any) -> Any:
    try:
        asyncio.get_running_loop()
    except RuntimeError:
        return asyncio.run(coro)

    with ThreadPoolExecutor(max_workers=1) as pool:
        fut = pool.submit(lambda: asyncio.run(coro))
        return fut.result()


def run_attacks_sync(
    attacks: Sequence[BleAttackTest],
    *,
    config: BlePentestConfig,
    report_writer: ReportWriter,
    concurrent: bool = False,
) -> list[AttackResult]:
    return run_coroutine_sync(
        run_attacks(
            attacks,
            config=config,
            report_writer=report_writer,
            concurrent=concurrent,
        )
    )


def ensure_unique_attack_names(attacks: Iterable[type[BleAttackTest]]) -> None:
    names: set[str] = set()
    for cls in attacks:
        if cls.name in names:
            raise ValueError(f"Duplicate attack name: {cls.name}")
        names.add(cls.name)
