"""Command line entry point for the BLE pentest harness."""

from __future__ import annotations

import argparse
import importlib
import inspect
from pathlib import Path
from typing import TYPE_CHECKING

from .base import BleAttackTest, ensure_unique_attack_names, run_attacks_sync
from .config import load_ble_config
from .reports import ReportWriter

if TYPE_CHECKING:
    from collections.abc import Iterable, Mapping, Sequence

    from .base import AttackContext
    from .config import BlePentestConfig


class NoopAttack(BleAttackTest):
    name = "noop"
    description = "No-op attack used for validating wiring"

    async def run(self, ctx: AttackContext):
        return {"note": "noop"}


class EchoTargetsAttack(BleAttackTest):
    name = "echo_targets"
    description = "Echoes configured targets (for testing/reporting)"

    async def run(self, ctx: AttackContext):
        return {
            "targets": [
                {"name": t.name, "address": t.address} for t in ctx.config.targets
            ],
        }


BUILTIN_ATTACKS: tuple[type[BleAttackTest], ...] = (
    NoopAttack,
    EchoTargetsAttack,
)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="ble-pentest")
    parser.add_argument(
        "--config",
        required=True,
        type=Path,
        help="Path to a BLE pentest YAML configuration",
    )
    parser.add_argument(
        "--out",
        dest="output_dir",
        default=Path("ble-reports"),
        type=Path,
        help="Directory to write JSON/Markdown reports to",
    )
    parser.add_argument(
        "--attacks",
        nargs="*",
        default=None,
        help="Attack names to run (defaults to those enabled in config)",
    )
    parser.add_argument(
        "--concurrent",
        action="store_true",
        help="Run selected attacks concurrently",
    )
    return parser


def parse_args(argv: Sequence[str] | None = None) -> argparse.Namespace:
    return build_parser().parse_args(argv)


def select_attack_names(
    config: BlePentestConfig,
    requested: Sequence[str] | None,
) -> tuple[str, ...]:
    if requested is None:
        return config.enabled_attacks()
    return tuple(requested)


def _discover_attack_classes(modules: Iterable[str]) -> tuple[type[BleAttackTest], ...]:
    discovered: list[type[BleAttackTest]] = []
    for mod_name in modules:
        module = importlib.import_module(mod_name)
        for _, obj in inspect.getmembers(module, inspect.isclass):
            if not issubclass(obj, BleAttackTest) or obj is BleAttackTest:
                continue
            discovered.append(obj)
    return tuple(discovered)


def get_available_attacks(
    config: BlePentestConfig,
) -> Mapping[str, type[BleAttackTest]]:
    extra = _discover_attack_classes(config.attack_modules)
    ensure_unique_attack_names((*BUILTIN_ATTACKS, *extra))

    attacks: dict[str, type[BleAttackTest]] = {}
    for cls in (*BUILTIN_ATTACKS, *extra):
        attacks[cls.name] = cls
    return attacks


def main(argv: Sequence[str] | None = None) -> int:
    args = parse_args(argv)
    config = load_ble_config(args.config)

    output_dir = args.output_dir
    report_writer = ReportWriter(output_dir)

    available = get_available_attacks(config)
    selected_names = select_attack_names(config, args.attacks)

    attacks: list[BleAttackTest] = []
    for name in selected_names:
        if name not in available:
            raise SystemExit(f"Unknown attack '{name}'. Available: {sorted(available)}")
        attacks.append(available[name]())

    results = run_attacks_sync(
        attacks,
        config=config,
        report_writer=report_writer,
        concurrent=args.concurrent,
    )
    report_writer.write_summary(results)

    return 0 if all(r.success for r in results) else 1


if __name__ == "__main__":
    raise SystemExit(main())
