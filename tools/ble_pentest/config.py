"""YAML configuration loading for the BLE pentest harness."""

from __future__ import annotations

from collections.abc import Mapping, Sequence
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Any


@dataclass(frozen=True)
class BleTarget:
    address: str
    name: str | None = None


@dataclass(frozen=True)
class BlePentestConfig:
    targets: tuple[BleTarget, ...] = ()
    credentials: dict[str, str] = field(default_factory=dict)
    attacks: dict[str, bool] = field(default_factory=dict)
    attack_modules: tuple[str, ...] = ()
    raw: dict[str, Any] = field(default_factory=dict)

    def enabled_attacks(self) -> tuple[str, ...]:
        return tuple(name for name, enabled in self.attacks.items() if enabled)


class BlePentestConfigError(ValueError):
    pass


def load_ble_config(path: str | Path) -> BlePentestConfig:
    path = Path(path)
    data = _load_yaml_file(path)
    if not isinstance(data, Mapping):
        raise BlePentestConfigError(f"Config root must be a mapping: {path}")
    return ble_config_from_mapping(data, source=path)


def ble_config_from_mapping(
    mapping: Mapping[str, Any], *, source: str | Path = "<mapping>"
) -> BlePentestConfig:
    targets_raw = mapping.get("targets", [])
    if targets_raw is None:
        targets_raw = []
    if not isinstance(targets_raw, Sequence) or isinstance(targets_raw, (str, bytes)):
        raise BlePentestConfigError(f"'targets' must be a list in {source}")

    targets: list[BleTarget] = []
    for item in targets_raw:
        if isinstance(item, str):
            targets.append(BleTarget(address=item))
            continue
        if isinstance(item, Mapping):
            address = item.get("address") or item.get("mac")
            if not address or not isinstance(address, str):
                raise BlePentestConfigError(
                    f"Each target must include an 'address' string in {source}"
                )
            name = item.get("name")
            if name is not None and not isinstance(name, str):
                raise BlePentestConfigError(
                    f"Target 'name' must be a string when provided in {source}"
                )
            targets.append(BleTarget(address=address, name=name))
            continue
        raise BlePentestConfigError(
            f"Target entries must be strings or mappings, got {type(item)!r} in {source}"
        )

    credentials_raw = mapping.get("credentials", {})
    if credentials_raw is None:
        credentials_raw = {}
    if not isinstance(credentials_raw, Mapping):
        raise BlePentestConfigError(f"'credentials' must be a mapping in {source}")
    credentials: dict[str, str] = {}
    for key, value in credentials_raw.items():
        if not isinstance(key, str) or not isinstance(value, str):
            raise BlePentestConfigError(
                f"'credentials' must contain string keys/values in {source}"
            )
        credentials[key] = value

    attacks_raw = mapping.get("attacks", {})
    if attacks_raw is None:
        attacks_raw = {}
    if not isinstance(attacks_raw, Mapping):
        raise BlePentestConfigError(f"'attacks' must be a mapping in {source}")
    attacks: dict[str, bool] = {}
    for key, value in attacks_raw.items():
        if not isinstance(key, str) or not isinstance(value, bool):
            raise BlePentestConfigError(
                f"'attacks' must contain string keys and boolean values in {source}"
            )
        attacks[key] = value

    attack_modules_raw = mapping.get("attack_modules", [])
    if attack_modules_raw is None:
        attack_modules_raw = []
    if not isinstance(attack_modules_raw, Sequence) or isinstance(
        attack_modules_raw, (str, bytes)
    ):
        raise BlePentestConfigError(f"'attack_modules' must be a list in {source}")
    attack_modules: list[str] = []
    for mod in attack_modules_raw:
        if not isinstance(mod, str):
            raise BlePentestConfigError(
                f"'attack_modules' entries must be strings in {source}"
            )
        attack_modules.append(mod)

    return BlePentestConfig(
        targets=tuple(targets),
        credentials=credentials,
        attacks=attacks,
        attack_modules=tuple(attack_modules),
        raw=dict(mapping),
    )


def _load_yaml_file(path: Path) -> Any:
    text = path.read_text(encoding="utf-8")

    try:
        from ruamel.yaml import YAML

        parser = YAML(typ="safe", pure=True)
        return parser.load(text)
    except ModuleNotFoundError:
        pass

    try:  # pragma: no cover
        import yaml  # type: ignore[import-not-found]

        return yaml.safe_load(text)
    except ModuleNotFoundError:  # pragma: no cover
        import json

        try:
            return json.loads(text)
        except json.JSONDecodeError as json_exc:
            raise RuntimeError(
                "YAML parsing requires ruamel.yaml (preferred) or PyYAML. "
                "As a fallback, JSON configs are supported."
            ) from json_exc
