from __future__ import annotations

import json
import sys
import types
from pathlib import Path

from tools.ble_pentest.base import AttackContext, run_coroutine_sync
from tools.ble_pentest.config import BlePentestConfig, BleTarget
from tools.ble_pentest.reports import ReportWriter


def _install_fake_bleak(*, scanner_payloads=None, client_reads=None):
    """Install a minimal fake bleak module into sys.modules.

    Parameters
    ----------
    scanner_payloads:
        Sequence of (device, advertisement_data) tuples delivered to the scanner's
        detection callback.
    client_reads:
        Sequence of bytes returned by successive read_gatt_char calls.
    """

    if scanner_payloads is None:
        scanner_payloads = []
    if client_reads is None:
        client_reads = []

    bleak_mod = types.ModuleType("bleak")

    class FakeScanner:
        def __init__(self, detection_callback=None, **kwargs):
            self.detection_callback = detection_callback
            self.kwargs = kwargs
            self.started = False
            self.stopped = False

        async def start(self):
            self.started = True
            for device, adv in scanner_payloads:
                if self.detection_callback:
                    self.detection_callback(device, adv)

        async def stop(self):
            self.stopped = True

    class FakeClient:
        instances = []

        def __init__(self, address, **kwargs):
            self.address = address
            self.kwargs = kwargs
            self.connected = False
            self.disconnected = False
            self.writes = []
            self._read_index = 0
            FakeClient.instances.append(self)

        async def connect(self):
            self.connected = True

        async def disconnect(self):
            self.disconnected = True

        async def read_gatt_char(self, uuid):
            if self._read_index < len(client_reads):
                value = client_reads[self._read_index]
            else:
                value = b""
            self._read_index += 1
            return value

        async def write_gatt_char(self, uuid, data, response=False):
            self.writes.append(
                {"uuid": uuid, "data": bytes(data), "response": response}
            )

    bleak_mod.BleakScanner = FakeScanner
    bleak_mod.BleakClient = FakeClient

    sys.modules["bleak"] = bleak_mod

    return FakeScanner, FakeClient


def test_sniffing_attack_captures_cleartext_and_writes_artifact(tmp_path):
    class Device:
        address = "AA:BB:CC:DD:EE:FF"
        name = "demo"
        rssi = -40

    class Adv:
        manufacturer_data = {76: b"user=demo;pin=0000"}
        service_data = {}
        service_uuids = ["0000180f-0000-1000-8000-00805f9b34fb"]

    _install_fake_bleak(scanner_payloads=[(Device(), Adv())])

    from tools.ble_pentest.attacks.sniffing import SniffingAttack

    cfg = BlePentestConfig(raw={"sniffing": {"timeout_seconds": 0.0}})
    writer = ReportWriter(tmp_path, run_id="testrun")
    ctx = AttackContext(config=cfg, report_writer=writer)

    result = run_coroutine_sync(SniffingAttack().execute(ctx))
    assert result.success is True
    assert result.details["events"] == ["scanner_start", "scanner_stop"]
    assert result.details["findings"], "expected cleartext heuristic finding"

    evidence = result.details["evidence"]["advertisements_jsonl"]
    assert Path(evidence).exists()

    paths = writer.write_summary([result])
    payload = json.loads(paths["json"].read_text(encoding="utf-8"))
    assert payload["results"][0]["attack"] == "sniffing"
    assert "advertisements_jsonl" in payload["results"][0]["details"]["evidence"]


def test_spoofing_attack_executes_write_and_records_advertisement(tmp_path):
    _, FakeClient = _install_fake_bleak()

    from tools.ble_pentest.attacks.spoofing import SpoofingAttack

    cfg = BlePentestConfig(
        targets=(BleTarget(address="11:22:33:44:55:66"),),
        raw={
            "spoofing": {
                "actions": [
                    {
                        "type": "advertisement",
                        "local_name": "Impersonated",
                        "manufacturer_data_hex": {76: "010203"},
                    },
                    {
                        "type": "write",
                        "characteristic_uuid": "00002a19-0000-1000-8000-00805f9b34fb",
                        "value_utf8": "hello",
                    },
                ]
            }
        },
    )
    writer = ReportWriter(tmp_path, run_id="testrun")
    ctx = AttackContext(config=cfg, report_writer=writer)

    result = run_coroutine_sync(SpoofingAttack().execute(ctx))
    assert result.success is True
    assert [a["type"] for a in result.details["actions"]] == [
        "advertisement",
        "write",
    ]
    assert result.details["actions"][0]["supported"] is False
    assert result.details["actions"][1]["status"] == "written"

    assert FakeClient.instances
    assert FakeClient.instances[0].writes

    paths = writer.write_summary([result])
    md = paths["markdown"].read_text(encoding="utf-8")
    assert "`spoofing`" in md


def test_replay_attack_records_captures_and_flags_replay_acceptance(tmp_path):
    _install_fake_bleak(client_reads=[b"abcd1234", b"abcd1234"])

    from tools.ble_pentest.attacks.replay import ReplayAttack

    cfg = BlePentestConfig(
        targets=(BleTarget(address="11:22:33:44:55:66"),),
        raw={
            "replay": {
                "characteristic_uuid": "00002a19-0000-1000-8000-00805f9b34fb",
                "capture_count": 2,
                "nonce_bytes": 4,
            }
        },
    )
    writer = ReportWriter(tmp_path, run_id="testrun")
    ctx = AttackContext(config=cfg, report_writer=writer)

    result = run_coroutine_sync(ReplayAttack().execute(ctx))
    assert result.success is True
    assert result.details["events"][0] == "connected"
    assert result.details["events"][-1] == "disconnect"
    assert len(result.details["captures"]) == 2
    assert len(result.details["replays"]) == 2
    assert {f["type"] for f in result.details["findings"]} >= {
        "nonce_static_suspected",
        "payload_static_suspected",
        "replay_write_accepted",
    }
